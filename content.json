{"pages":[],"posts":[{"title":"【数据结构与算法】 快速幂算法","text":"计算x的n次方是数学上基础的运算之一。在计算机中，要完成同样的计算，如果采用符合常识的循环相乘的方式，则算法的时间复杂度为O(n)。除此之外，还有一种巧妙利用二进制特点的幂算法 —— 快速幂算法，其时间复杂度仅为O(logn)。通过快速幂算法可以领略算法之美~ 代码首先先看快速幂算法的代码： 123456789101112class Solution { public double myPow(double x, int n) { double ans = 1.0; for(int i = n; i != 0; i /= 2){ if(i % 2 != 0){ ans *= x; } x *= x; } return n &lt; 0 ? 1 / ans : ans; }} 快速幂算法的代码逻辑比较简单，大体的思路是：我们以求 x 的 n 次方为例，将 n 不断向右移位（除以2）直到 n 为0，每次移位时若 n 末位为1（即对2取模为0），则 x 乘进结果 ans 中，同时每次移位时，令 x 为 x 的平方，最终结果考虑 n 的正负性即可。从算法的代码中可以清楚地看出，其时间复杂度为 O(logn) 。 原理同样我们以求 x 的 n 次方为例，我们把 n 写成二进制的形式，记作： x^{n}=x^{[b_{n}b_{n-1}...b_{2}b_{1}]}由于： [b_{n}b_{n-1}...b_{2}b_{1}]=[b_{n}000...]+[b_{n-1}000...]+[b_{2}0]+[b_{1}]那么原式可以改写为： x^{n}=x^{[b_{n}b_{n-1}...b_{2}b_{1}]}=x^{[b_{n}b_{n-1}...b_{2}b_{1}]}=x^{[b_{n}000...]}x^{[b_{n-1}000...]}x^{[b_{2}0]}x^{[b_{1}]}即 x 的 n 次方等于 x 与 [n 各二进制位构成的数字次方]的乘积，而其中： x^{[b_{i}000...]}=x^{[b_{i-1}000...]}x^{[b_{i-1}000...]} \\quad 例如: x^{8}=x^{4}x^{4}由此，再看快速幂的计算计算流程，其中就利用了上述的特性，将 n 分别计算每一位对应的幂，若当前位为1则乘如结果，若当前位为0，则 x ^ bi 为1，结果不变，同时利用这一位的幂来计算下一位的幂。 快速幂算法利用了指数幂和二进制的特点，大大降低了运算的复杂度，是一种非常巧妙的算法。","link":"/2022/08/31/fastpower/"},{"title":"【音视频开发】 FFmpeg 常用基础命令","text":"FFmpeg是音视频处理领域的一把利剑，本文总结了一些基础且实用FFmpeg命令 基础命令最基础的视频转封装-i 用于指定输入文件，最后面的是输出文件，FFmpeg会自动帮助我们转封装1ffmpeg -i input.mp4 out.mov 指定编码器软件编码（软编，CPU），FFmpeg默认：1ffmpeg -i input.mp4 -c:v libx264 out.mov硬件编码（硬编，GPU）：1ffmpeg -i input.mp4 -c:v h264_nvenc out.mov 指定视频质量preset:预设，指编码器指定的一些预设值，参数列表：ultrafast、superfast、veryfast、faster、fast、medium（默认）、slow、slower、veryslow从左到右编码速度递减，但是生成的文件也同时变小（俗话说慢工出细活）1ffmpeg -i input.mp4 -c:v libx264 -preset veryslow out.movcrf (Constant Rate Factor) :控制图像质量，取值0-51，0质量最好，51最差，常用的是19-281ffmpeg -i input.mp4 -c:v libx264 -crf 22 out.mov 视频剪切与合并视频剪切：12345# ss: 起始位置, t: 时长ffmpeg -i input.mp4 -c:v libx264 -ss 00:00:00 -t 5 out.movffmpeg -i input.mp4 -c:v libx264 -ss 00:00:00 -t 00:00:05 out.mov# ss: 起始位置, to: 终止位置ffmpeg -i input.mp4 -c:v libx264 -ss 00:00:00 -to 00:00:10 out.mov视频合并：用文本文件list.txt定义视频合并列表：123file '1.mp4'file '2.mp4'file '3.mp4'FFmpeg命令12# -f concat 代表输入是视频列表，-c copy 代表直接拷贝原视频码流ffmpeg -f concat list.txt -c copy out.mp4 修改视频(filter)FFmpeg 中可以使用 filter 对视频进行一些修改操作，例如裁剪、缩放、旋转、滤镜，以及其他更复杂的操作等等：-vf 用于指定一个视频 filter ， -af 用于指定一个视频 filter-vn 删除视频轨，-an 删除音频轨，-sn 删除字幕流缩放视频：1234# 指定长和宽ffmpeg -i input.mp4 -c:v libx264 -vf &quot;scale=1024:500&quot; out.mov# 指定长，自动推算宽ffmpeg -i input.mp4 -c:v libx264 -vf &quot;scale=1024:-1&quot; out.mov裁剪视频：1234# crop=w:h:x:yffmpeg -i input.mp4 -c:v libx264 -vf &quot;crop=400:400:100:100&quot; out.mov# iw: input width, ih: input heightffmpeg -i input.mp4 -c:v libx264 -vf &quot;crop=iw/2:ih/2:100:100&quot; out.movfilter 组合：12# 逗号分隔多个filter 先缩放再旋转ffmpeg -i input.mp4 -c:v libx264 -vf &quot;scale=1024:500, transpose=1&quot; out.mov 实用命令视频加水印1ffmpeg -i input.mp4 -i mark.png -filter_complex &quot;overlay=100:100&quot; out.mp4 视频缩略截图1ffmpeg -i input.mp4 -vf &quot;fps=1/10,scale=-1:720&quot; thumbnail-%03d.jpg 视频转gif1ffmpeg -i input.mp4 -ss 00:00:00 -to 00:00:10 -filter_complex &quot;[0:v]fps=15,scale=-1:256,split[a][b];[a]palettegen[p];[b][p]paletteuse&quot; out.gif","link":"/2022/08/31/ffmpeg_cmd_tutorial/"},{"title":"【环境配置】 Centos7 安装 Nginx","text":"Nginx简介 Nginx是一个高性能的HTTP和反向代理web服务器，具有占有内存少，并发能力强等优点 一. 安装所需环境1. gcc安装 安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境1yum install gcc-c++ 2. PCRE pcre-devel 安装 nginx 的 http 模块使用 PCRE 来解析正则表达式1yum install -y pcre pcre-devel 3. zlib 安装 nginx 使用 zlib 对 http 包的内容进行 gzip1yum install -y zlib zlib-devel 4. OpenSSL 安装 nginx 支持 https 协议1yum install -y openssl openssl-devel 二. 下载、解压、配置、编译、安装源码包1. 使用wget下载 这里下载的是1.12.0版本的nginx1wget -c https://nginx.org/download/nginx-1.12.0.tar.gz -若没有安装wget，则使用以下命令安装wget1yum install wget 2. 解压 直接解压1tar -zxvf nginx-1.12.0.tar.gz 然后移动到解压完后的目录中1cd nginx-1.12.0 3. 配置 使用默认配置1./configure 4. 编译和安装 执行以下命令1make 1make install 5. 查看安装位置 执行以下命令查看nginx安装位置，一般位于/usr/local/nginx1whereis nginx 三. 启动、停止、重启、开机自启动1. 启动、停止、重启Nginx 移动至nginx目录1cd /usr/local/nginx/sbin/ 启动1./nginx 退出（待nginx进程处理任务完毕）1./nginx -s quit 强制退出1./nginx -s stop 重启1./nginx -s reload 2. 开机自启动 在rc.local增加启动代码1vi /etc/rc.local 增加一行：1/usr/local/nginx/sbin/nginx 设置执行权限1chmod 755 rc.local","link":"/2022/08/31/nginx-install/"},{"title":"【Java】 线程池基本概念","text":"Java语言虽然内置了多线程支持，可以显式的创建线程并启动运行。但是，创建新的线程需要消耗操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。 为解决这些问题，Java标准库中提供了线程池（Thread Pool），以实现线程的复用。用一句话概括线程池的功能就是：线程池通过内部维护若干个线程用于接收小任务并进行处理。 阿里巴巴开发规约中强制规定，线程资源必须通过线程池提供，不允许在应用中自行显式创建线程，由此可见线程池在实际开发中的重要性。 线程池的创建Java标准库中采用 ExecutorService 接口来表示线程池，线程池的创建有多种方式，其中最简单的一种是通过 Executors 类中提供的静态方法来创建： 12345678// 创建一个固定大小的线程池:ExecutorService es = Executors.newFixedThreadPool(5);// 创建一个线程数根据任务动态调整的线程池:ExecutorService es = Executors.newCachedThreadPool();// 创建一个仅单线程执行的线程池:ExecutorService es = Executors.newSingleThreadExecutor(); 如果需要自己定制化线程池，则需要使用 new ThreadPoolExecutor() 的方式，其实如果看上述三个静态方法的源码，其中也都使用了 new ThreadPoolExecutor() 的方式：1234// 固定大小的线程池:public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());} 我们看 ThreadPoolExecutor 类的构造方法，其中最基础的是：1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 方法有7个参数，这七个参数就是所谓的线程池七大参数，其具体含义如下： 参数 名称 int corePoolSize 核心线程数 int maximumPoolSize 最大线程数 long keepAliveTime 存活时间 TimeUnit unit 时间单位 BlockingQueue&lt;Runnable&gt; workQueue 阻塞队列 ThreadFactory threadFactory 线程工厂 RejectedExecutionHandler handler 拒绝策略 线程池的使用线程池的基本使用思想就是先创建线程池，然后向线程池中提交任务，任务需要实现 Runnable 接口 1234567// 创建固定大小的线程池:ExecutorService executor = Executors.newFixedThreadPool(3);// 提交任务:executor.submit(task1);executor.submit(task2);executor.submit(task3);executor.submit(task4); 下面是一个使用线程池的Demo 12345678910111213141516171819202122232425262728293031import java.util.concurrent.*;public class Main { public static void main(String[] args) { // 创建一个固定大小的线程池: ExecutorService es = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 6; i++) { es.submit(new Task(&quot;&quot; + i)); } // 关闭线程池: es.shutdown(); }}class Task implements Runnable { private final String name; public Task(String name) { this.name = name; } @Override public void run() { System.out.println(&quot;start task &quot; + name); try { Thread.sleep(1000); } catch (InterruptedException e) { } System.out.println(&quot;end task &quot; + name); }}","link":"/2022/08/31/threadpool/"},{"title":"【设计模式】 观察者模式（Obverser）","text":"观察者模式是设计模式中行为型模式的一种。在实际开发中有着很普遍的应用 观察者模式（Observer）定义了一种通知机制，让发送通知的一方（Subject）和接收通知的一方（Observer）能彼此分离，互不影响。我们直接看代码： 首先定义观察者接口123public interface Observer { void update();} 观察者实现观察者接口123456789101112131415public class ObserverA implements Observer{ @Override public void update() { System.out.println(&quot;execute ObserverA code&quot;); }}public class ObserverB implements Observer{ @Override public void update() { System.out.println(&quot;execute ObserverB code&quot;); }} 我们定义一个被订阅的主题，可以看到主题中维护了一个观察者的list，观察者订阅主题时，将其加入list1234567891011121314151617181920212223public class Subject { List&lt;Observer&gt; list = new ArrayList&lt;&gt;(); public Subject(){ System.out.println(&quot;init subject&quot;); } public void doUpdate(){ for(Observer o : list){ o.update(); } } public void addObserver(Observer observer){ this.list.add(observer); } public void removeObserver(Observer observer){ this.list.remove(observer); }} 注意Subject类中的doUpdate方法，当主题更新时，通知所有订阅的观察者执行其update方法12345public void doUpdate(){ for(Observer o : list){ o.update(); }} 观察者模式使用逻辑1234567891011121314151617181920212223242526public class Main { public static void main(String[] args) { // 初始化 subject Subject subject = new Subject(); // 添加观察者 Observer a = new ObserverA(); Observer b = new ObserverB(); subject.addObserver(a); subject.addObserver(b); // 添加匿名观察者 subject.addObserver(() -&gt; System.out.println(&quot;Anonymous observer code&quot;)); // 主题更新，通知每个观察者 subject.doUpdate(); // 移除一个观察者 subject.removeObserver(b); // 主题更新，通知每个观察者 subject.doUpdate(); }} 运行结果123456init subjectexecute ObserverA codeexecute ObserverB codeAnonymous observer codeexecute ObserverA codeAnonymous observer code","link":"/2022/08/31/observer/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"ffmpeg","slug":"ffmpeg","link":"/tags/ffmpeg/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"环境配置","slug":"环境配置","link":"/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"音视频开发","slug":"音视频开发","link":"/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"},{"name":"环境配置","slug":"环境配置","link":"/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"Java开发","slug":"Java开发","link":"/categories/Java%E5%BC%80%E5%8F%91/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}